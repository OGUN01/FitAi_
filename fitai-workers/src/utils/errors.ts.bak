/**
 * FitAI Workers - Error Handling Utilities
 *
 * Custom error classes and error response formatters
 */

import { HTTPStatus, ErrorCode, APIResponse } from './types';

// ============================================================================
// CUSTOM ERROR CLASSES
// ============================================================================

/**
 * Base API Error class
 */
export class APIError extends Error {
  public readonly statusCode: number;
  public readonly errorCode: ErrorCode;
  public readonly details?: any;

  constructor(message: string, statusCode: number, errorCode: ErrorCode, details?: any) {
    super(message);
    this.name = 'APIError';
    this.statusCode = statusCode;
    this.errorCode = errorCode;
    this.details = details;
  }
}

/**
 * Authentication Error (401)
 */
export class UnauthorizedError extends APIError {
  constructor(message: string = 'Unauthorized', details?: any) {
    super(message, HTTPStatus.UNAUTHORIZED, ErrorCode.UNAUTHORIZED, details);
    this.name = 'UnauthorizedError';
  }
}

/**
 * Validation Error (400)
 */
export class ValidationError extends APIError {
  constructor(message: string = 'Validation failed', details?: any) {
    super(message, HTTPStatus.BAD_REQUEST, ErrorCode.VALIDATION_ERROR, details);
    this.name = 'ValidationError';
  }
}

/**
 * Rate Limit Error (429)
 */
export class RateLimitError extends APIError {
  public readonly limit: number;
  public readonly resetAt: number;

  constructor(message: string, limit: number, resetAt: number) {
    super(message, HTTPStatus.RATE_LIMIT_EXCEEDED, ErrorCode.RATE_LIMIT_EXCEEDED, { limit, resetAt });
    this.name = 'RateLimitError';
    this.limit = limit;
    this.resetAt = resetAt;
  }
}

/**
 * Not Found Error (404)
 */
export class NotFoundError extends APIError {
  constructor(message: string = 'Resource not found', details?: any) {
    super(message, HTTPStatus.NOT_FOUND, ErrorCode.MEDIA_NOT_FOUND, details);
    this.name = 'NotFoundError';
  }
}

/**
 * Internal Server Error (500)
 */
export class InternalServerError extends APIError {
  constructor(message: string = 'Internal server error', details?: any) {
    super(message, HTTPStatus.INTERNAL_SERVER_ERROR, ErrorCode.INTERNAL_ERROR, details);
    this.name = 'InternalServerError';
  }
}

/**
 * Service Unavailable Error (503)
 */
export class ServiceUnavailableError extends APIError {
  constructor(message: string = 'Service temporarily unavailable', details?: any) {
    super(message, HTTPStatus.SERVICE_UNAVAILABLE, ErrorCode.SERVICE_UNAVAILABLE, details);
    this.name = 'ServiceUnavailableError';
  }
}

// ============================================================================
// ERROR RESPONSE FORMATTERS
// ============================================================================

/**
 * Format error as API response
 */
export function formatErrorResponse(error: Error | APIError): APIResponse {
  // If it's our custom APIError, use its properties
  if (error instanceof APIError) {
    return {
      success: false,
      error: {
        code: error.errorCode,
        message: error.message,
        details: error.details,
      },
    };
  }

  // For unknown errors, return generic internal error
  return {
    success: false,
    error: {
      code: ErrorCode.INTERNAL_ERROR,
      message: error.message || 'An unexpected error occurred',
      // Note: In production, stack traces should not be exposed to clients
      // details: error.stack, // Uncomment for development debugging
    },
  };
}

/**
 * Create HTTP Response from error
 */
export function createErrorResponse(error: Error | APIError): Response {
  const statusCode = error instanceof APIError ? error.statusCode : HTTPStatus.INTERNAL_SERVER_ERROR;
  const apiResponse = formatErrorResponse(error);

  // Add rate limit headers for rate limit errors
  const headers: Record<string, string> = {
    'Content-Type': 'application/json',
  };

  if (error instanceof RateLimitError) {
    headers['X-RateLimit-Limit'] = error.limit.toString();
    headers['X-RateLimit-Reset'] = error.resetAt.toString();
  }

  return new Response(JSON.stringify(apiResponse, null, 2), {
    status: statusCode,
    headers,
  });
}

/**
 * Log error with context
 */
export function logError(error: Error, context?: Record<string, any>): void {
  const errorLog = {
    name: error.name,
    message: error.message,
    stack: error.stack,
    ...context,
    timestamp: new Date().toISOString(),
  };

  console.error('[ERROR]', JSON.stringify(errorLog, null, 2));
}

/**
 * Safe error handler wrapper for async functions
 */
export function withErrorHandling<T>(
  handler: () => Promise<T>,
  context?: Record<string, any>
): Promise<T> {
  return handler().catch((error) => {
    logError(error, context);
    throw error;
  });
}
